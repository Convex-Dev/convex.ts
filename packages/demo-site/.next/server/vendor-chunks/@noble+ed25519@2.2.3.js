"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+ed25519@2.2.3";
exports.ids = ["vendor-chunks/@noble+ed25519@2.2.3"];
exports.modules = {

/***/ "(pages-dir-node)/../../node_modules/.pnpm/@noble+ed25519@2.2.3/node_modules/@noble/ed25519/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@noble+ed25519@2.2.3/node_modules/@noble/ed25519/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   ExtendedPoint: () => (/* binding */ Point),\n/* harmony export */   etc: () => (/* binding */ etc),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getPublicKeyAsync: () => (/* binding */ getPublicKeyAsync),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signAsync: () => (/* binding */ signAsync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify),\n/* harmony export */   verifyAsync: () => (/* binding */ verifyAsync)\n/* harmony export */ });\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of ed25519 EDDSA signatures compliant with RFC8032, FIPS 186-5 & ZIP215.\n * @module\n */\nconst P = 2n ** 255n - 19n; // ed25519 is twisted edwards curve\nconst N = 2n ** 252n + 27742317777372353535851937790883648493n; // curve's (group) order\nconst Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an; // base point x\nconst Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n; // base point y\nconst _d = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\n/**\n * ed25519 curve parameters. Equation is −x² + y² = -a + dx²y².\n * Gx and Gy are generator coordinates. p is field order, n is group order.\n * h is cofactor.\n */\nconst CURVE = {\n    a: -1n, // -1 mod p\n    d: _d, // -(121665/121666) mod p\n    p: P, n: N, h: 8, Gx: Gx, Gy: Gy // field prime, curve (group) order, cofactor\n};\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst isS = (s) => typeof s === 'string'; // is string\nconst isu8 = (a) => (a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array'));\nconst au8 = (a, l) => // is Uint8Array (of specific length)\n !isu8(a) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array of valid length expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(isS(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst M = (a, b = P) => { let r = a % b; return r >= 0n ? r : b + r; }; // mod division\nconst isPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is xyzt point\n/** Point in xyzt extended coordinates. */\nclass Point {\n    constructor(ex, ey, ez, et) {\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n    }\n    static fromAffine(p) { return new Point(p.x, p.y, 1n, M(p.x * p.y)); }\n    /** RFC8032 5.1.3: hex / Uint8Array to Point. */\n    static fromHex(hex, zip215 = false) {\n        const { d } = CURVE;\n        hex = toU8(hex, 32);\n        const normed = hex.slice(); // copy the array to not mess it up\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80; // adjust first LE byte = last BE byte\n        const y = b2n_LE(normed); // decode as little-endian, convert to num\n        if (zip215 && !(0n <= y && y < 2n ** 256n))\n            err('bad y coord 1'); // zip215=true  [1..2^256-1]\n        if (!zip215 && !(0n <= y && y < P))\n            err('bad y coord 2'); // zip215=false [1..P-1]\n        const y2 = M(y * y); // y²\n        const u = M(y2 - 1n); // u=y²-1\n        const v = M(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad y coordinate 3'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad y coord 3'); // x=0 and x_0 = 1\n        if (isLastByteOdd !== isXOdd)\n            x = M(-x);\n        return new Point(x, y, 1n, M(x * y)); // Z=1, T=xy\n    }\n    get x() { return this.toAffine().x; } // .x, .y will call expensive toAffine.\n    get y() { return this.toAffine().y; } // Should be used with care.\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other); // isPoint() checks class equality\n        const X1Z2 = M(X1 * Z2), X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2), Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() { return this.equals(I); }\n    negate() {\n        return new Point(M(-this.ex), this.ey, this.ez, M(-this.et));\n    }\n    /** Point doubling. Complete formula. */\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this; // Cost: 4M + 4S + 1*a + 6add + 1*2\n        const { a } = CURVE; // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /** Point addition. Complete formula. */\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this; // Cost: 8M + 1*k + 8add + 1*2.\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other); // doesn't check if other on-curve\n        const { a, d } = CURVE; // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    mul(n, safe = true) {\n        if (n === 0n)\n            return safe === true ? err('cannot multiply by 0') : I;\n        if (!(typeof n === 'bigint' && 0n < n && n < N))\n            err('invalid scalar, must be < L');\n        if (!safe && this.is0() || n === 1n)\n            return this; // safe=true bans 0. safe=false allows 0.\n        if (this.equals(G))\n            return wNAF(n).p; // use wNAF precomputes for base points\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    multiply(scalar) { return this.mul(scalar); } // Aliases for compatibilty\n    clearCofactor() { return this.mul(BigInt(CURVE.h), false); } // multiply by cofactor\n    isSmallOrder() { return this.clearCofactor().is0(); } // check if P is small order\n    isTorsionFree() {\n        let p = this.mul(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1)             // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    /** converts point to 2d xy affine point. (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy). */\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this;\n        if (this.equals(I))\n            return { x: 0n, y: 1n }; // fast-path for zero point\n        const iz = invert(z, P); // z^-1: invert z\n        if (M(z * iz) !== 1n)\n            err('invalid inverse'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: M(x * iz), y: M(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    toRawBytes() {\n        const { x, y } = this.toAffine(); // convert to affine 2d point\n        const b = n2b_32LE(y); // encode number to 32 bytes\n        b[31] |= x & 1n ? 0x80 : 0; // store sign in first LE byte\n        return b;\n    }\n    toHex() { return b2h(this.toRawBytes()); } // encode to hex string\n}\n/** Generator / Base point */\nPoint.BASE = new Point(Gx, Gy, 1n, M(Gx * Gy));\n/** Identity / Zero point */\nPoint.ZERO = new Point(0n, 1n, 1n, 0n);\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (num, pad) => num.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(au8(b)).map(e => padh(e, 2)).join(''); // bytes to hex\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst h2b = (hex) => {\n    const e = 'hex invalid';\n    if (!isS(hex))\n        return err(e);\n    const hl = hex.length, al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) { // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst n2b_32LE = (num) => h2b(padh(num, 32 * 2)).reverse(); // number to bytes LE\nconst b2n_LE = (b) => BigInt('0x' + b2h(u8n(au8(b)).reverse())); // bytes LE to num\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst pow2 = (x, power) => {\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\nconst uvRatio = (u, v) => {\n    const v3 = M(v * v * v); // v³\n    const v7 = M(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = M(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = M(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = M(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === M(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === M(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((M(x) & 1n) === 1n)\n        x = M(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\nconst modL_LE = (hash) => M(b2n_LE(hash), N); // modulo L; but little-endian\nlet _shaS;\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => // Sync SHA512, not set by default\n typeof _shaS === 'function' ? _shaS(...m) : err('etc.sha512Sync not set');\nconst hash2extK = (hashed) => {\n    const head = hashed.slice(0, 32); // slice creates a copy, unlike subarray\n    head[0] &= 248; // Clamp bits: 0b1111_1000,\n    head[31] &= 127; // 0b0111_1111,\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(32, 64); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.mul(scalar); // public key point\n    const pointBytes = point.toRawBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, 32)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, 32)));\n/** Creates 32-byte ed25519 public key from 32-byte private key. Async. */\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then(p => p.pointBytes);\n/** Creates 32-byte ed25519 public key from 32-byte private key. To use, set `etc.sha512Sync` first. */\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nfunction hashFinish(asynchronous, res) {\n    if (asynchronous)\n        return sha512a(res.hashable).then(res.finish);\n    return res.finish(sha512s(res.hashable));\n}\nconst _sign = (e, rBytes, msg) => {\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.mul(r).toRawBytes(); // R = [r]B\n    const hashable = concatB(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        const S = M(r + modL_LE(hashed) * s, N); // S = (r + k * s) mod L; 0 <= s < l\n        return au8(concatB(R, n2b_32LE(S)), 64); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\n/** Signs message (NOT message hash) using private key. Async. */\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key async\n    const e = await getExtendedPublicKeyAsync(privKey); // pub,prfx\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(true, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\n/** Signs message (NOT message hash) using private key. To use, set `etc.sha512Sync` first. */\nconst sign = (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key sync\n    const e = getExtendedPublicKey(privKey); // pub,prfx\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(false, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst dvo = { zip215: true };\nconst _verify = (sig, msg, pub, opts = dvo) => {\n    sig = toU8(sig, 64); // Signature hex str/Bytes, must be 64 bytes\n    msg = toU8(msg); // Message hex str/Bytes\n    pub = toU8(pub, 32);\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A, R, s, SB, hashable = new Uint8Array();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, 32), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = b2n_LE(sig.slice(32, 64)); // Decode second half as an integer S\n        SB = G.mul(s, false); // in the range 0 <= s < L\n        hashable = concatB(R.toRawBytes(), A.toRawBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.mul(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n// RFC8032 5.1.7: verification async, sync\n/** Verifies signature on message and public key. Async. */\nconst verifyAsync = async (s, m, p, opts = dvo) => hashFinish(true, _verify(s, m, p, opts));\n/** Verifies signature on message and public key. To use, set `etc.sha512Sync` first. */\nconst verify = (s, m, p, opts = dvo) => hashFinish(false, _verify(s, m, p, opts));\nconst cr = () => // We support: 1) browsers 2) node.js 19+\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    bytesToHex: b2h,\n    hexToBytes: h2b,\n    concatBytes: concatB,\n    mod: M,\n    invert: invert,\n    randomBytes: (len = 32) => {\n        const c = cr(); // Can be shimmed in node.js <= 18 to prevent error:\n        // import { webcrypto } from 'node:crypto';\n        // if (!globalThis.crypto) globalThis.crypto = webcrypto;\n        if (!c || !c.getRandomValues)\n            err('crypto.getRandomValues must be defined');\n        return c.getRandomValues(u8n(len));\n    },\n    sha512Async: async (...messages) => {\n        const c = cr();\n        const s = c && c.subtle;\n        if (!s)\n            err('etc.sha512Async or crypto.subtle must be defined');\n        const m = concatB(...messages);\n        return u8n(await s.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined, // Actual logic below\n};\nObject.defineProperties(etc, { sha512Sync: {\n        configurable: false, get() { return _shaS; }, set(f) { if (!_shaS)\n            _shaS = f; },\n    } });\n/** ed25519-specific key utilities. */\nconst utils = {\n    getExtendedPublicKeyAsync: getExtendedPublicKeyAsync,\n    getExtendedPublicKey: getExtendedPublicKey,\n    randomPrivateKey: () => etc.randomBytes(32),\n    precompute: (w = 8, p = G) => { p.multiply(3n); w; return p; }, // no-op\n};\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\n // envs like browser console\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2VkMjU1MTlAMi4yLjMvbm9kZV9tb2R1bGVzL0Bub2JsZS9lZDI1NTE5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGdFQUFnRTtBQUNoRSxnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxrRUFBa0U7QUFDbEUsMEJBQTBCLGVBQWUsK0JBQStCO0FBQ3hFLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsY0FBYyxvQkFBb0IsaUJBQWlCLHVCQUF1QjtBQUMxRTtBQUNBLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEMsdURBQXVEO0FBQ3ZEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQyxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLHlCQUF5QixrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUIsUUFBUTtBQUNqRCxnQkFB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QUFzQjtBQUN0QixvQkFBb0IsYUFBYSxPQUFPO0FBQ3hDLGVBQWU7QUFDZix3QkFBd0I7QUFDeEIsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDhCQUE4QixvQkFBb0IsdUJBQXVCO0FBQ3pFLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLHFDQUFxQztBQUNyQywyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0Esc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNERBQTREO0FBQzVELG9EQUFvRDtBQUNwRDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGVBQWU7QUFDZiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixHQUFHO0FBRWlFLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWlrZV9cXGdpdFxcY29udmV4LnRzXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAbm9ibGUrZWQyNTUxOUAyLjIuM1xcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGVkMjU1MTlcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1lZDI1NTE5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMTkgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vKipcbiAqIDRLQiBKUyBpbXBsZW1lbnRhdGlvbiBvZiBlZDI1NTE5IEVERFNBIHNpZ25hdHVyZXMgY29tcGxpYW50IHdpdGggUkZDODAzMiwgRklQUyAxODYtNSAmIFpJUDIxNS5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgUCA9IDJuICoqIDI1NW4gLSAxOW47IC8vIGVkMjU1MTkgaXMgdHdpc3RlZCBlZHdhcmRzIGN1cnZlXG5jb25zdCBOID0gMm4gKiogMjUybiArIDI3NzQyMzE3Nzc3MzcyMzUzNTM1ODUxOTM3NzkwODgzNjQ4NDkzbjsgLy8gY3VydmUncyAoZ3JvdXApIG9yZGVyXG5jb25zdCBHeCA9IDB4MjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYW47IC8vIGJhc2UgcG9pbnQgeFxuY29uc3QgR3kgPSAweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NThuOyAvLyBiYXNlIHBvaW50IHlcbmNvbnN0IF9kID0gMzcwOTU3MDU5MzQ2Njk0MzkzNDMxMzgwODM1MDg3NTQ1NjUxODk1NDIxMTM4Nzk4NDMyMTkwMTYzODg3ODU1MzMwODU5NDAyODM1NTVuO1xuLyoqXG4gKiBlZDI1NTE5IGN1cnZlIHBhcmFtZXRlcnMuIEVxdWF0aW9uIGlzIOKIknjCsiArIHnCsiA9IC1hICsgZHjCsnnCsi5cbiAqIEd4IGFuZCBHeSBhcmUgZ2VuZXJhdG9yIGNvb3JkaW5hdGVzLiBwIGlzIGZpZWxkIG9yZGVyLCBuIGlzIGdyb3VwIG9yZGVyLlxuICogaCBpcyBjb2ZhY3Rvci5cbiAqL1xuY29uc3QgQ1VSVkUgPSB7XG4gICAgYTogLTFuLCAvLyAtMSBtb2QgcFxuICAgIGQ6IF9kLCAvLyAtKDEyMTY2NS8xMjE2NjYpIG1vZCBwXG4gICAgcDogUCwgbjogTiwgaDogOCwgR3g6IEd4LCBHeTogR3kgLy8gZmllbGQgcHJpbWUsIGN1cnZlIChncm91cCkgb3JkZXIsIGNvZmFjdG9yXG59O1xuY29uc3QgZXJyID0gKG0gPSAnJykgPT4geyB0aHJvdyBuZXcgRXJyb3IobSk7IH07IC8vIGVycm9yIGhlbHBlciwgbWVzc2VzLXVwIHN0YWNrIHRyYWNlXG5jb25zdCBpc1MgPSAocykgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnOyAvLyBpcyBzdHJpbmdcbmNvbnN0IGlzdTggPSAoYSkgPT4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbmNvbnN0IGF1OCA9IChhLCBsKSA9PiAvLyBpcyBVaW50OEFycmF5IChvZiBzcGVjaWZpYyBsZW5ndGgpXG4gIWlzdTgoYSkgfHwgKHR5cGVvZiBsID09PSAnbnVtYmVyJyAmJiBsID4gMCAmJiBhLmxlbmd0aCAhPT0gbCkgP1xuICAgIGVycignVWludDhBcnJheSBvZiB2YWxpZCBsZW5ndGggZXhwZWN0ZWQnKSA6IGE7XG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdG9VOCA9IChhLCBsZW4pID0+IGF1OChpc1MoYSkgPyBoMmIoYSkgOiB1OG4oYXU4KGEpKSwgbGVuKTsgLy8gbm9ybShoZXgvdThhKSB0byB1OGFcbmNvbnN0IE0gPSAoYSwgYiA9IFApID0+IHsgbGV0IHIgPSBhICUgYjsgcmV0dXJuIHIgPj0gMG4gPyByIDogYiArIHI7IH07IC8vIG1vZCBkaXZpc2lvblxuY29uc3QgaXNQb2ludCA9IChwKSA9PiAocCBpbnN0YW5jZW9mIFBvaW50ID8gcCA6IGVycignUG9pbnQgZXhwZWN0ZWQnKSk7IC8vIGlzIHh5enQgcG9pbnRcbi8qKiBQb2ludCBpbiB4eXp0IGV4dGVuZGVkIGNvb3JkaW5hdGVzLiAqL1xuY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGV4LCBleSwgZXosIGV0KSB7XG4gICAgICAgIHRoaXMuZXggPSBleDtcbiAgICAgICAgdGhpcy5leSA9IGV5O1xuICAgICAgICB0aGlzLmV6ID0gZXo7XG4gICAgICAgIHRoaXMuZXQgPSBldDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUocCkgeyByZXR1cm4gbmV3IFBvaW50KHAueCwgcC55LCAxbiwgTShwLnggKiBwLnkpKTsgfVxuICAgIC8qKiBSRkM4MDMyIDUuMS4zOiBoZXggLyBVaW50OEFycmF5IHRvIFBvaW50LiAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgemlwMjE1ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBkIH0gPSBDVVJWRTtcbiAgICAgICAgaGV4ID0gdG9VOChoZXgsIDMyKTtcbiAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgdGhlIGFycmF5IHRvIG5vdCBtZXNzIGl0IHVwXG4gICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4WzMxXTtcbiAgICAgICAgbm9ybWVkWzMxXSA9IGxhc3RCeXRlICYgfjB4ODA7IC8vIGFkanVzdCBmaXJzdCBMRSBieXRlID0gbGFzdCBCRSBieXRlXG4gICAgICAgIGNvbnN0IHkgPSBiMm5fTEUobm9ybWVkKTsgLy8gZGVjb2RlIGFzIGxpdHRsZS1lbmRpYW4sIGNvbnZlcnQgdG8gbnVtXG4gICAgICAgIGlmICh6aXAyMTUgJiYgISgwbiA8PSB5ICYmIHkgPCAybiAqKiAyNTZuKSlcbiAgICAgICAgICAgIGVycignYmFkIHkgY29vcmQgMScpOyAvLyB6aXAyMTU9dHJ1ZSAgWzEuLjJeMjU2LTFdXG4gICAgICAgIGlmICghemlwMjE1ICYmICEoMG4gPD0geSAmJiB5IDwgUCkpXG4gICAgICAgICAgICBlcnIoJ2JhZCB5IGNvb3JkIDInKTsgLy8gemlwMjE1PWZhbHNlIFsxLi5QLTFdXG4gICAgICAgIGNvbnN0IHkyID0gTSh5ICogeSk7IC8vIHnCslxuICAgICAgICBjb25zdCB1ID0gTSh5MiAtIDFuKTsgLy8gdT15wrItMVxuICAgICAgICBjb25zdCB2ID0gTShkICogeTIgKyAxbik7IC8vIHY9ZHnCsisxXG4gICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyAodXbCsykodXbigbcpXihwLTUpLzg7IHNxdWFyZSByb290XG4gICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgIGVycignYmFkIHkgY29vcmRpbmF0ZSAzJyk7IC8vIG5vdCBzcXVhcmUgcm9vdDogYmFkIHBvaW50XG4gICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgMW4pID09PSAxbjsgLy8gYWRqdXN0IHNpZ24gb2YgeCBjb29yZGluYXRlXG4gICAgICAgIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAweDgwKSAhPT0gMDsgLy8geF8wLCBsYXN0IGJpdFxuICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSAwbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgZXJyKCdiYWQgeSBjb29yZCAzJyk7IC8vIHg9MCBhbmQgeF8wID0gMVxuICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgeCA9IE0oLXgpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIDFuLCBNKHggKiB5KSk7IC8vIFo9MSwgVD14eVxuICAgIH1cbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54OyB9IC8vIC54LCAueSB3aWxsIGNhbGwgZXhwZW5zaXZlIHRvQWZmaW5lLlxuICAgIGdldCB5KCkgeyByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7IH0gLy8gU2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLlxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiB9ID0gaXNQb2ludChvdGhlcik7IC8vIGlzUG9pbnQoKSBjaGVja3MgY2xhc3MgZXF1YWxpdHlcbiAgICAgICAgY29uc3QgWDFaMiA9IE0oWDEgKiBaMiksIFgyWjEgPSBNKFgyICogWjEpO1xuICAgICAgICBjb25zdCBZMVoyID0gTShZMSAqIFoyKSwgWTJaMSA9IE0oWTIgKiBaMSk7XG4gICAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgfVxuICAgIGlzMCgpIHsgcmV0dXJuIHRoaXMuZXF1YWxzKEkpOyB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KE0oLXRoaXMuZXgpLCB0aGlzLmV5LCB0aGlzLmV6LCBNKC10aGlzLmV0KSk7XG4gICAgfVxuICAgIC8qKiBQb2ludCBkb3VibGluZy4gQ29tcGxldGUgZm9ybXVsYS4gKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpczsgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjJcbiAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTsgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgY29uc3QgQSA9IE0oWDEgKiBYMSk7XG4gICAgICAgIGNvbnN0IEIgPSBNKFkxICogWTEpO1xuICAgICAgICBjb25zdCBDID0gTSgybiAqIE0oWjEgKiBaMSkpO1xuICAgICAgICBjb25zdCBEID0gTShhICogQSk7XG4gICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICBjb25zdCBFID0gTShNKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTtcbiAgICAgICAgY29uc3QgRyA9IEQgKyBCO1xuICAgICAgICBjb25zdCBGID0gRyAtIEM7XG4gICAgICAgIGNvbnN0IEggPSBEIC0gQjtcbiAgICAgICAgY29uc3QgWDMgPSBNKEUgKiBGKTtcbiAgICAgICAgY29uc3QgWTMgPSBNKEcgKiBIKTtcbiAgICAgICAgY29uc3QgVDMgPSBNKEUgKiBIKTtcbiAgICAgICAgY29uc3QgWjMgPSBNKEYgKiBHKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgfVxuICAgIC8qKiBQb2ludCBhZGRpdGlvbi4gQ29tcGxldGUgZm9ybXVsYS4gKi9cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxLCBldDogVDEgfSA9IHRoaXM7IC8vIENvc3Q6IDhNICsgMSprICsgOGFkZCArIDEqMi5cbiAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyLCBldDogVDIgfSA9IGlzUG9pbnQob3RoZXIpOyAvLyBkb2Vzbid0IGNoZWNrIGlmIG90aGVyIG9uLWN1cnZlXG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7IC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gICAgICAgIGNvbnN0IEEgPSBNKFgxICogWDIpO1xuICAgICAgICBjb25zdCBCID0gTShZMSAqIFkyKTtcbiAgICAgICAgY29uc3QgQyA9IE0oVDEgKiBkICogVDIpO1xuICAgICAgICBjb25zdCBEID0gTShaMSAqIFoyKTtcbiAgICAgICAgY29uc3QgRSA9IE0oKFgxICsgWTEpICogKFgyICsgWTIpIC0gQSAtIEIpO1xuICAgICAgICBjb25zdCBGID0gTShEIC0gQyk7XG4gICAgICAgIGNvbnN0IEcgPSBNKEQgKyBDKTtcbiAgICAgICAgY29uc3QgSCA9IE0oQiAtIGEgKiBBKTtcbiAgICAgICAgY29uc3QgWDMgPSBNKEUgKiBGKTtcbiAgICAgICAgY29uc3QgWTMgPSBNKEcgKiBIKTtcbiAgICAgICAgY29uc3QgVDMgPSBNKEUgKiBIKTtcbiAgICAgICAgY29uc3QgWjMgPSBNKEYgKiBHKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgfVxuICAgIG11bChuLCBzYWZlID0gdHJ1ZSkge1xuICAgICAgICBpZiAobiA9PT0gMG4pXG4gICAgICAgICAgICByZXR1cm4gc2FmZSA9PT0gdHJ1ZSA/IGVycignY2Fubm90IG11bHRpcGx5IGJ5IDAnKSA6IEk7XG4gICAgICAgIGlmICghKHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiAwbiA8IG4gJiYgbiA8IE4pKVxuICAgICAgICAgICAgZXJyKCdpbnZhbGlkIHNjYWxhciwgbXVzdCBiZSA8IEwnKTtcbiAgICAgICAgaWYgKCFzYWZlICYmIHRoaXMuaXMwKCkgfHwgbiA9PT0gMW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gc2FmZT10cnVlIGJhbnMgMC4gc2FmZT1mYWxzZSBhbGxvd3MgMC5cbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEcpKVxuICAgICAgICAgICAgcmV0dXJuIHdOQUYobikucDsgLy8gdXNlIHdOQUYgcHJlY29tcHV0ZXMgZm9yIGJhc2UgcG9pbnRzXG4gICAgICAgIGxldCBwID0gSSwgZiA9IEc7IC8vIGluaXQgcmVzdWx0IHBvaW50ICYgZmFrZSBwb2ludFxuICAgICAgICBmb3IgKGxldCBkID0gdGhpczsgbiA+IDBuOyBkID0gZC5kb3VibGUoKSwgbiA+Pj0gMW4pIHsgLy8gZG91YmxlLWFuZC1hZGQgbGFkZGVyXG4gICAgICAgICAgICBpZiAobiAmIDFuKVxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTsgLy8gaWYgYml0IGlzIHByZXNlbnQsIGFkZCB0byBwb2ludFxuICAgICAgICAgICAgZWxzZSBpZiAoc2FmZSlcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoZCk7IC8vIGlmIG5vdCwgYWRkIHRvIGZha2UgZm9yIHRpbWluZyBzYWZldHlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7IHJldHVybiB0aGlzLm11bChzY2FsYXIpOyB9IC8vIEFsaWFzZXMgZm9yIGNvbXBhdGliaWx0eVxuICAgIGNsZWFyQ29mYWN0b3IoKSB7IHJldHVybiB0aGlzLm11bChCaWdJbnQoQ1VSVkUuaCksIGZhbHNlKTsgfSAvLyBtdWx0aXBseSBieSBjb2ZhY3RvclxuICAgIGlzU21hbGxPcmRlcigpIHsgcmV0dXJuIHRoaXMuY2xlYXJDb2ZhY3RvcigpLmlzMCgpOyB9IC8vIGNoZWNrIGlmIFAgaXMgc21hbGwgb3JkZXJcbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICBsZXQgcCA9IHRoaXMubXVsKE4gLyAybiwgZmFsc2UpLmRvdWJsZSgpOyAvLyBlbnN1cmVzIHRoZSBwb2ludCBpcyBub3QgXCJiYWRcIi5cbiAgICAgICAgaWYgKE4gJSAybilcbiAgICAgICAgICAgIHAgPSBwLmFkZCh0aGlzKTsgLy8gUF4oTisxKSAgICAgICAgICAgICAvLyBQKk4gPT0gKFAqKE4vMikpKjIrUFxuICAgICAgICByZXR1cm4gcC5pczAoKTtcbiAgICB9XG4gICAgLyoqIGNvbnZlcnRzIHBvaW50IHRvIDJkIHh5IGFmZmluZSBwb2ludC4gKHgsIHksIHosIHQpIOKIiyAoeD14L3osIHk9eS96LCB0PXh5KS4gKi9cbiAgICB0b0FmZmluZSgpIHtcbiAgICAgICAgY29uc3QgeyBleDogeCwgZXk6IHksIGV6OiB6IH0gPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkpXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwbiwgeTogMW4gfTsgLy8gZmFzdC1wYXRoIGZvciB6ZXJvIHBvaW50XG4gICAgICAgIGNvbnN0IGl6ID0gaW52ZXJ0KHosIFApOyAvLyB6Xi0xOiBpbnZlcnQgelxuICAgICAgICBpZiAoTSh6ICogaXopICE9PSAxbilcbiAgICAgICAgICAgIGVycignaW52YWxpZCBpbnZlcnNlJyk7IC8vICh6ICogel4tMSkgbXVzdCBiZSAxLCBvdGhlcndpc2UgYmFkIG1hdGhcbiAgICAgICAgcmV0dXJuIHsgeDogTSh4ICogaXopLCB5OiBNKHkgKiBpeikgfTsgLy8geCA9IHgqel4tMTsgeSA9IHkqel4tMVxuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTsgLy8gY29udmVydCB0byBhZmZpbmUgMmQgcG9pbnRcbiAgICAgICAgY29uc3QgYiA9IG4yYl8zMkxFKHkpOyAvLyBlbmNvZGUgbnVtYmVyIHRvIDMyIGJ5dGVzXG4gICAgICAgIGJbMzFdIHw9IHggJiAxbiA/IDB4ODAgOiAwOyAvLyBzdG9yZSBzaWduIGluIGZpcnN0IExFIGJ5dGVcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHRvSGV4KCkgeyByZXR1cm4gYjJoKHRoaXMudG9SYXdCeXRlcygpKTsgfSAvLyBlbmNvZGUgdG8gaGV4IHN0cmluZ1xufVxuLyoqIEdlbmVyYXRvciAvIEJhc2UgcG9pbnQgKi9cblBvaW50LkJBU0UgPSBuZXcgUG9pbnQoR3gsIEd5LCAxbiwgTShHeCAqIEd5KSk7XG4vKiogSWRlbnRpdHkgLyBaZXJvIHBvaW50ICovXG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KDBuLCAxbiwgMW4sIDBuKTtcbmNvbnN0IHsgQkFTRTogRywgWkVSTzogSSB9ID0gUG9pbnQ7IC8vIEdlbmVyYXRvciwgaWRlbnRpdHkgcG9pbnRzXG5jb25zdCBwYWRoID0gKG51bSwgcGFkKSA9PiBudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KHBhZCwgJzAnKTtcbmNvbnN0IGIyaCA9IChiKSA9PiBBcnJheS5mcm9tKGF1OChiKSkubWFwKGUgPT4gcGFkaChlLCAyKSkuam9pbignJyk7IC8vIGJ5dGVzIHRvIGhleFxuY29uc3QgQyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9OyAvLyBBU0NJSSBjaGFyYWN0ZXJzXG5jb25zdCBfY2ggPSAoY2gpID0+IHtcbiAgICBpZiAoY2ggPj0gQy5fMCAmJiBjaCA8PSBDLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBDLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gQy5BICYmIGNoIDw9IEMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKEMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gQy5hICYmIGNoIDw9IEMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKEMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59O1xuY29uc3QgaDJiID0gKGhleCkgPT4ge1xuICAgIGNvbnN0IGUgPSAnaGV4IGludmFsaWQnO1xuICAgIGlmICghaXNTKGhleCkpXG4gICAgICAgIHJldHVybiBlcnIoZSk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoLCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICByZXR1cm4gZXJyKGUpO1xuICAgIGNvbnN0IGFycmF5ID0gdThuKGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikgeyAvLyB0cmVhdCBlYWNoIGNoYXIgYXMgQVNDSUlcbiAgICAgICAgY29uc3QgbjEgPSBfY2goaGV4LmNoYXJDb2RlQXQoaGkpKTsgLy8gcGFyc2UgZmlyc3QgY2hhciwgbXVsdGlwbHkgaXQgYnkgMTZcbiAgICAgICAgY29uc3QgbjIgPSBfY2goaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7IC8vIHBhcnNlIHNlY29uZCBjaGFyXG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXJyKGUpO1xuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIGV4YW1wbGU6ICdBOScgPT4gMTAqMTYgKyA5XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5jb25zdCBuMmJfMzJMRSA9IChudW0pID0+IGgyYihwYWRoKG51bSwgMzIgKiAyKSkucmV2ZXJzZSgpOyAvLyBudW1iZXIgdG8gYnl0ZXMgTEVcbmNvbnN0IGIybl9MRSA9IChiKSA9PiBCaWdJbnQoJzB4JyArIGIyaCh1OG4oYXU4KGIpKS5yZXZlcnNlKCkpKTsgLy8gYnl0ZXMgTEUgdG8gbnVtXG5jb25zdCBjb25jYXRCID0gKC4uLmFycnMpID0+IHtcbiAgICBjb25zdCByID0gdThuKGFycnMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGF1OChhKS5sZW5ndGgsIDApKTsgLy8gY3JlYXRlIHU4YSBvZiBzdW1tZWQgbGVuZ3RoXG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGFycmF5LFxuICAgIGFycnMuZm9yRWFjaChhID0+IHsgci5zZXQoYSwgcGFkKTsgcGFkICs9IGEubGVuZ3RoOyB9KTsgLy8gZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIHJldHVybiByO1xufTtcbmNvbnN0IGludmVydCA9IChudW0sIG1kKSA9PiB7XG4gICAgaWYgKG51bSA9PT0gMG4gfHwgbWQgPD0gMG4pXG4gICAgICAgIGVycignbm8gaW52ZXJzZSBuPScgKyBudW0gKyAnIG1vZD0nICsgbWQpOyAvLyBubyBuZWcgZXhwb25lbnQgZm9yIG5vd1xuICAgIGxldCBhID0gTShudW0sIG1kKSwgYiA9IG1kLCB4ID0gMG4sIHkgPSAxbiwgdSA9IDFuLCB2ID0gMG47XG4gICAgd2hpbGUgKGEgIT09IDBuKSB7IC8vIHVzZXMgZXVjbGlkZWFuIGdjZCBhbGdvcml0aG1cbiAgICAgICAgY29uc3QgcSA9IGIgLyBhLCByID0gYiAlIGE7IC8vIG5vdCBjb25zdGFudC10aW1lXG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHEsIG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIHJldHVybiBiID09PSAxbiA/IE0oeCwgbWQpIDogZXJyKCdubyBpbnZlcnNlJyk7IC8vIGIgaXMgZ2NkIGF0IHRoaXMgcG9pbnRcbn07XG5jb25zdCBwb3cyID0gKHgsIHBvd2VyKSA9PiB7XG4gICAgbGV0IHIgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gMG4pIHtcbiAgICAgICAgciAqPSByO1xuICAgICAgICByICU9IFA7XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcbmNvbnN0IHBvd18yXzI1Ml8zID0gKHgpID0+IHtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQOyAvLyB4XjIsICAgICAgIGJpdHMgMVxuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsICAgICAgIGJpdHMgMTFcbiAgICBjb25zdCBiNCA9IChwb3cyKGIyLCAybikgKiBiMikgJSBQOyAvLyB4XigyXjQtMSksIGJpdHMgMTExMVxuICAgIGNvbnN0IGI1ID0gKHBvdzIoYjQsIDFuKSAqIHgpICUgUDsgLy8geF4oMl41LTEpLCBiaXRzIDExMTExXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIDVuKSAqIGI1KSAlIFA7IC8vIHheKDJeMTApXG4gICAgY29uc3QgYjIwID0gKHBvdzIoYjEwLCAxMG4pICogYjEwKSAlIFA7IC8vIHheKDJeMjApXG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCAyMG4pICogYjIwKSAlIFA7IC8vIHheKDJeNDApXG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCA0MG4pICogYjQwKSAlIFA7IC8vIHheKDJeODApXG4gICAgY29uc3QgYjE2MCA9IChwb3cyKGI4MCwgODBuKSAqIGI4MCkgJSBQOyAvLyB4XigyXjE2MClcbiAgICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgODBuKSAqIGI4MCkgJSBQOyAvLyB4XigyXjI0MClcbiAgICBjb25zdCBiMjUwID0gKHBvdzIoYjI0MCwgMTBuKSAqIGIxMCkgJSBQOyAvLyB4XigyXjI1MClcbiAgICBjb25zdCBwb3dfcF81XzggPSAocG93MihiMjUwLCAybikgKiB4KSAlIFA7IC8vIDwgVG8gcG93IHRvIChwKzMpLzgsIG11bHRpcGx5IGl0IGJ5IHguXG4gICAgcmV0dXJuIHsgcG93X3BfNV84LCBiMiB9O1xufTtcbmNvbnN0IFJNMSA9IDE5NjgxMTYxMzc2NzA3NTA1OTU2ODA3MDc5MzA0OTg4NTQyMDE1NDQ2MDY2NTE1OTIzODkwMTYyNzQ0MDIxMDczMTIzODI5Nzg0NzUybjsgLy8g4oiaLTFcbmNvbnN0IHV2UmF0aW8gPSAodSwgdikgPT4ge1xuICAgIGNvbnN0IHYzID0gTSh2ICogdiAqIHYpOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IE0odjMgKiB2MyAqIHYpOyAvLyB24oG3XG4gICAgY29uc3QgcG93ID0gcG93XzJfMjUyXzModSAqIHY3KS5wb3dfcF81Xzg7IC8vICh1duKBtyleKHAtNSkvOFxuICAgIGxldCB4ID0gTSh1ICogdjMgKiBwb3cpOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBNKHYgKiB4ICogeCk7IC8vIHZ4wrJcbiAgICBjb25zdCByb290MSA9IHg7IC8vIEZpcnN0IHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3Qgcm9vdDIgPSBNKHggKiBSTTEpOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGU7IFJNMSBpcyDiiJotMVxuICAgIGNvbnN0IHVzZVJvb3QxID0gdngyID09PSB1OyAvLyBJZiB2eMKyID0gdSAobW9kIHApLCB4IGlzIGEgc3F1YXJlIHJvb3RcbiAgICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gTSgtdSk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gTSgtdSAqIFJNMSk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImi0xXG4gICAgaWYgKHVzZVJvb3QxKVxuICAgICAgICB4ID0gcm9vdDE7XG4gICAgaWYgKHVzZVJvb3QyIHx8IG5vUm9vdClcbiAgICAgICAgeCA9IHJvb3QyOyAvLyBXZSByZXR1cm4gcm9vdDIgYW55d2F5LCBmb3IgY29uc3QtdGltZVxuICAgIGlmICgoTSh4KSAmIDFuKSA9PT0gMW4pXG4gICAgICAgIHggPSBNKC14KTsgLy8gZWRJc05lZ2F0aXZlXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59O1xuY29uc3QgbW9kTF9MRSA9IChoYXNoKSA9PiBNKGIybl9MRShoYXNoKSwgTik7IC8vIG1vZHVsbyBMOyBidXQgbGl0dGxlLWVuZGlhblxubGV0IF9zaGFTO1xuY29uc3Qgc2hhNTEyYSA9ICguLi5tKSA9PiBldGMuc2hhNTEyQXN5bmMoLi4ubSk7IC8vIEFzeW5jIFNIQTUxMlxuY29uc3Qgc2hhNTEycyA9ICguLi5tKSA9PiAvLyBTeW5jIFNIQTUxMiwgbm90IHNldCBieSBkZWZhdWx0XG4gdHlwZW9mIF9zaGFTID09PSAnZnVuY3Rpb24nID8gX3NoYVMoLi4ubSkgOiBlcnIoJ2V0Yy5zaGE1MTJTeW5jIG5vdCBzZXQnKTtcbmNvbnN0IGhhc2gyZXh0SyA9IChoYXNoZWQpID0+IHtcbiAgICBjb25zdCBoZWFkID0gaGFzaGVkLnNsaWNlKDAsIDMyKTsgLy8gc2xpY2UgY3JlYXRlcyBhIGNvcHksIHVubGlrZSBzdWJhcnJheVxuICAgIGhlYWRbMF0gJj0gMjQ4OyAvLyBDbGFtcCBiaXRzOiAwYjExMTFfMTAwMCxcbiAgICBoZWFkWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExLFxuICAgIGhlYWRbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZSgzMiwgNjQpOyAvLyBwcml2YXRlIGtleSBcInByZWZpeFwiXG4gICAgY29uc3Qgc2NhbGFyID0gbW9kTF9MRShoZWFkKTsgLy8gbW9kdWxhciBkaXZpc2lvbiBvdmVyIGN1cnZlIG9yZGVyXG4gICAgY29uc3QgcG9pbnQgPSBHLm11bChzY2FsYXIpOyAvLyBwdWJsaWMga2V5IHBvaW50XG4gICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gcG9pbnQgc2VyaWFsaXplZCB0byBVaW50OEFycmF5XG4gICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG59O1xuLy8gUkZDODAzMiA1LjEuNTsgZ2V0UHVibGljS2V5IGFzeW5jLCBzeW5jLiBIYXNoIHByaXYga2V5IGFuZCBleHRyYWN0IHBvaW50LlxuY29uc3QgZ2V0RXh0ZW5kZWRQdWJsaWNLZXlBc3luYyA9IChwcml2KSA9PiBzaGE1MTJhKHRvVTgocHJpdiwgMzIpKS50aGVuKGhhc2gyZXh0Syk7XG5jb25zdCBnZXRFeHRlbmRlZFB1YmxpY0tleSA9IChwcml2KSA9PiBoYXNoMmV4dEsoc2hhNTEycyh0b1U4KHByaXYsIDMyKSkpO1xuLyoqIENyZWF0ZXMgMzItYnl0ZSBlZDI1NTE5IHB1YmxpYyBrZXkgZnJvbSAzMi1ieXRlIHByaXZhdGUga2V5LiBBc3luYy4gKi9cbmNvbnN0IGdldFB1YmxpY0tleUFzeW5jID0gKHByaXYpID0+IGdldEV4dGVuZGVkUHVibGljS2V5QXN5bmMocHJpdikudGhlbihwID0+IHAucG9pbnRCeXRlcyk7XG4vKiogQ3JlYXRlcyAzMi1ieXRlIGVkMjU1MTkgcHVibGljIGtleSBmcm9tIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuIFRvIHVzZSwgc2V0IGBldGMuc2hhNTEyU3luY2AgZmlyc3QuICovXG5jb25zdCBnZXRQdWJsaWNLZXkgPSAocHJpdikgPT4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdikucG9pbnRCeXRlcztcbmZ1bmN0aW9uIGhhc2hGaW5pc2goYXN5bmNocm9ub3VzLCByZXMpIHtcbiAgICBpZiAoYXN5bmNocm9ub3VzKVxuICAgICAgICByZXR1cm4gc2hhNTEyYShyZXMuaGFzaGFibGUpLnRoZW4ocmVzLmZpbmlzaCk7XG4gICAgcmV0dXJuIHJlcy5maW5pc2goc2hhNTEycyhyZXMuaGFzaGFibGUpKTtcbn1cbmNvbnN0IF9zaWduID0gKGUsIHJCeXRlcywgbXNnKSA9PiB7XG4gICAgY29uc3QgeyBwb2ludEJ5dGVzOiBQLCBzY2FsYXI6IHMgfSA9IGU7XG4gICAgY29uc3QgciA9IG1vZExfTEUockJ5dGVzKTsgLy8gciB3YXMgY3JlYXRlZCBvdXRzaWRlLCByZWR1Y2UgaXQgbW9kdWxvIExcbiAgICBjb25zdCBSID0gRy5tdWwocikudG9SYXdCeXRlcygpOyAvLyBSID0gW3JdQlxuICAgIGNvbnN0IGhhc2hhYmxlID0gY29uY2F0QihSLCBQLCBtc2cpOyAvLyBkb20yKEYsIEMpIHx8IFIgfHwgQSB8fCBQSChNKVxuICAgIGNvbnN0IGZpbmlzaCA9IChoYXNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgUyA9IE0ociArIG1vZExfTEUoaGFzaGVkKSAqIHMsIE4pOyAvLyBTID0gKHIgKyBrICogcykgbW9kIEw7IDAgPD0gcyA8IGxcbiAgICAgICAgcmV0dXJuIGF1OChjb25jYXRCKFIsIG4yYl8zMkxFKFMpKSwgNjQpOyAvLyA2NC1ieXRlIHNpZzogMzJiIFIueCArIDMyYiBMRShTKVxuICAgIH07XG4gICAgcmV0dXJuIHsgaGFzaGFibGUsIGZpbmlzaCB9O1xufTtcbi8qKiBTaWducyBtZXNzYWdlIChOT1QgbWVzc2FnZSBoYXNoKSB1c2luZyBwcml2YXRlIGtleS4gQXN5bmMuICovXG5jb25zdCBzaWduQXN5bmMgPSBhc3luYyAobXNnLCBwcml2S2V5KSA9PiB7XG4gICAgY29uc3QgbSA9IHRvVTgobXNnKTsgLy8gUkZDODAzMiA1LjEuNjogc2lnbiBtc2cgd2l0aCBrZXkgYXN5bmNcbiAgICBjb25zdCBlID0gYXdhaXQgZ2V0RXh0ZW5kZWRQdWJsaWNLZXlBc3luYyhwcml2S2V5KTsgLy8gcHViLHByZnhcbiAgICBjb25zdCByQnl0ZXMgPSBhd2FpdCBzaGE1MTJhKGUucHJlZml4LCBtKTsgLy8gciA9IFNIQTUxMihkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKSlcbiAgICByZXR1cm4gaGFzaEZpbmlzaCh0cnVlLCBfc2lnbihlLCByQnl0ZXMsIG0pKTsgLy8gZ2VuIFIsIGssIFMsIHRoZW4gNjQtYnl0ZSBzaWduYXR1cmVcbn07XG4vKiogU2lnbnMgbWVzc2FnZSAoTk9UIG1lc3NhZ2UgaGFzaCkgdXNpbmcgcHJpdmF0ZSBrZXkuIFRvIHVzZSwgc2V0IGBldGMuc2hhNTEyU3luY2AgZmlyc3QuICovXG5jb25zdCBzaWduID0gKG1zZywgcHJpdktleSkgPT4ge1xuICAgIGNvbnN0IG0gPSB0b1U4KG1zZyk7IC8vIFJGQzgwMzIgNS4xLjY6IHNpZ24gbXNnIHdpdGgga2V5IHN5bmNcbiAgICBjb25zdCBlID0gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSk7IC8vIHB1YixwcmZ4XG4gICAgY29uc3QgckJ5dGVzID0gc2hhNTEycyhlLnByZWZpeCwgbSk7IC8vIHIgPSBTSEE1MTIoZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSkpXG4gICAgcmV0dXJuIGhhc2hGaW5pc2goZmFsc2UsIF9zaWduKGUsIHJCeXRlcywgbSkpOyAvLyBnZW4gUiwgaywgUywgdGhlbiA2NC1ieXRlIHNpZ25hdHVyZVxufTtcbmNvbnN0IGR2byA9IHsgemlwMjE1OiB0cnVlIH07XG5jb25zdCBfdmVyaWZ5ID0gKHNpZywgbXNnLCBwdWIsIG9wdHMgPSBkdm8pID0+IHtcbiAgICBzaWcgPSB0b1U4KHNpZywgNjQpOyAvLyBTaWduYXR1cmUgaGV4IHN0ci9CeXRlcywgbXVzdCBiZSA2NCBieXRlc1xuICAgIG1zZyA9IHRvVTgobXNnKTsgLy8gTWVzc2FnZSBoZXggc3RyL0J5dGVzXG4gICAgcHViID0gdG9VOChwdWIsIDMyKTtcbiAgICBjb25zdCB7IHppcDIxNSB9ID0gb3B0czsgLy8gc3dpdGNoIGJldHdlZW4gemlwMjE1IGFuZCByZmM4MDMyIHZlcmlmXG4gICAgbGV0IEEsIFIsIHMsIFNCLCBoYXNoYWJsZSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgQSA9IFBvaW50LmZyb21IZXgocHViLCB6aXAyMTUpOyAvLyBwdWJsaWMga2V5IEEgZGVjb2RlZFxuICAgICAgICBSID0gUG9pbnQuZnJvbUhleChzaWcuc2xpY2UoMCwgMzIpLCB6aXAyMTUpOyAvLyAwIDw9IFIgPCAyXjI1NjogWklQMjE1IFIgY2FuIGJlID49IFBcbiAgICAgICAgcyA9IGIybl9MRShzaWcuc2xpY2UoMzIsIDY0KSk7IC8vIERlY29kZSBzZWNvbmQgaGFsZiBhcyBhbiBpbnRlZ2VyIFNcbiAgICAgICAgU0IgPSBHLm11bChzLCBmYWxzZSk7IC8vIGluIHRoZSByYW5nZSAwIDw9IHMgPCBMXG4gICAgICAgIGhhc2hhYmxlID0gY29uY2F0QihSLnRvUmF3Qnl0ZXMoKSwgQS50b1Jhd0J5dGVzKCksIG1zZyk7IC8vIGRvbTIoRiwgQykgfHwgUiB8fCBBIHx8IFBIKE0pXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgZmluaXNoID0gKGhhc2hlZCkgPT4ge1xuICAgICAgICBpZiAoU0IgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UgaWYgdHJ5LWNhdGNoIGNhdGNoZWQgYW4gZXJyb3JcbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UgZm9yIFNCUzogU3Ryb25nbHkgQmluZGluZyBTaWduYXR1cmVcbiAgICAgICAgY29uc3QgayA9IG1vZExfTEUoaGFzaGVkKTsgLy8gZGVjb2RlIGluIGxpdHRsZS1lbmRpYW4sIG1vZHVsbyBMXG4gICAgICAgIGNvbnN0IFJrQSA9IFIuYWRkKEEubXVsKGssIGZhbHNlKSk7IC8vIFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLmFkZChTQi5uZWdhdGUoKSkuY2xlYXJDb2ZhY3RvcigpLmlzMCgpOyAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG4gICAgfTtcbiAgICByZXR1cm4geyBoYXNoYWJsZSwgZmluaXNoIH07XG59O1xuLy8gUkZDODAzMiA1LjEuNzogdmVyaWZpY2F0aW9uIGFzeW5jLCBzeW5jXG4vKiogVmVyaWZpZXMgc2lnbmF0dXJlIG9uIG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIEFzeW5jLiAqL1xuY29uc3QgdmVyaWZ5QXN5bmMgPSBhc3luYyAocywgbSwgcCwgb3B0cyA9IGR2bykgPT4gaGFzaEZpbmlzaCh0cnVlLCBfdmVyaWZ5KHMsIG0sIHAsIG9wdHMpKTtcbi8qKiBWZXJpZmllcyBzaWduYXR1cmUgb24gbWVzc2FnZSBhbmQgcHVibGljIGtleS4gVG8gdXNlLCBzZXQgYGV0Yy5zaGE1MTJTeW5jYCBmaXJzdC4gKi9cbmNvbnN0IHZlcmlmeSA9IChzLCBtLCBwLCBvcHRzID0gZHZvKSA9PiBoYXNoRmluaXNoKGZhbHNlLCBfdmVyaWZ5KHMsIG0sIHAsIG9wdHMpKTtcbmNvbnN0IGNyID0gKCkgPT4gLy8gV2Ugc3VwcG9ydDogMSkgYnJvd3NlcnMgMikgbm9kZS5qcyAxOStcbiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLyoqIE1hdGgsIGhleCwgYnl0ZSBoZWxwZXJzLiBOb3QgaW4gYHV0aWxzYCBiZWNhdXNlIHV0aWxzIHNoYXJlIEFQSSB3aXRoIG5vYmxlLWN1cnZlcy4gKi9cbmNvbnN0IGV0YyA9IHtcbiAgICBieXRlc1RvSGV4OiBiMmgsXG4gICAgaGV4VG9CeXRlczogaDJiLFxuICAgIGNvbmNhdEJ5dGVzOiBjb25jYXRCLFxuICAgIG1vZDogTSxcbiAgICBpbnZlcnQ6IGludmVydCxcbiAgICByYW5kb21CeXRlczogKGxlbiA9IDMyKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjcigpOyAvLyBDYW4gYmUgc2hpbW1lZCBpbiBub2RlLmpzIDw9IDE4IHRvIHByZXZlbnQgZXJyb3I6XG4gICAgICAgIC8vIGltcG9ydCB7IHdlYmNyeXB0byB9IGZyb20gJ25vZGU6Y3J5cHRvJztcbiAgICAgICAgLy8gaWYgKCFnbG9iYWxUaGlzLmNyeXB0bykgZ2xvYmFsVGhpcy5jcnlwdG8gPSB3ZWJjcnlwdG87XG4gICAgICAgIGlmICghYyB8fCAhYy5nZXRSYW5kb21WYWx1ZXMpXG4gICAgICAgICAgICBlcnIoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiBjLmdldFJhbmRvbVZhbHVlcyh1OG4obGVuKSk7XG4gICAgfSxcbiAgICBzaGE1MTJBc3luYzogYXN5bmMgKC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjcigpO1xuICAgICAgICBjb25zdCBzID0gYyAmJiBjLnN1YnRsZTtcbiAgICAgICAgaWYgKCFzKVxuICAgICAgICAgICAgZXJyKCdldGMuc2hhNTEyQXN5bmMgb3IgY3J5cHRvLnN1YnRsZSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgY29uc3QgbSA9IGNvbmNhdEIoLi4ubWVzc2FnZXMpO1xuICAgICAgICByZXR1cm4gdThuKGF3YWl0IHMuZGlnZXN0KCdTSEEtNTEyJywgbS5idWZmZXIpKTtcbiAgICB9LFxuICAgIHNoYTUxMlN5bmM6IHVuZGVmaW5lZCwgLy8gQWN0dWFsIGxvZ2ljIGJlbG93XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXRjLCB7IHNoYTUxMlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwgZ2V0KCkgeyByZXR1cm4gX3NoYVM7IH0sIHNldChmKSB7IGlmICghX3NoYVMpXG4gICAgICAgICAgICBfc2hhUyA9IGY7IH0sXG4gICAgfSB9KTtcbi8qKiBlZDI1NTE5LXNwZWNpZmljIGtleSB1dGlsaXRpZXMuICovXG5jb25zdCB1dGlscyA9IHtcbiAgICBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jOiBnZXRFeHRlbmRlZFB1YmxpY0tleUFzeW5jLFxuICAgIGdldEV4dGVuZGVkUHVibGljS2V5OiBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBldGMucmFuZG9tQnl0ZXMoMzIpLFxuICAgIHByZWNvbXB1dGU6ICh3ID0gOCwgcCA9IEcpID0+IHsgcC5tdWx0aXBseSgzbik7IHc7IHJldHVybiBwOyB9LCAvLyBuby1vcFxufTtcbmNvbnN0IFcgPSA4OyAvLyBQcmVjb21wdXRlcy1yZWxhdGVkIGNvZGUuIFcgPSB3aW5kb3cgc2l6ZVxuY29uc3QgcHJlY29tcHV0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTsgLy8gMTB4IHNpZ24oKSwgMnggdmVyaWZ5KCkuIFRvIGFjaGlldmUgdGhpcyxcbiAgICBjb25zdCB3aW5kb3dzID0gMjU2IC8gVyArIDE7IC8vIGFwcCBuZWVkcyB0byBzcGVuZCA0MG1zKyB0byBjYWxjdWxhdGVcbiAgICBsZXQgcCA9IEcsIGIgPSBwOyAvLyBhIGxvdCBvZiBwb2ludHMgcmVsYXRlZCB0byBiYXNlIHBvaW50IEcuXG4gICAgZm9yIChsZXQgdyA9IDA7IHcgPCB3aW5kb3dzOyB3KyspIHsgLy8gUG9pbnRzIGFyZSBzdG9yZWQgaW4gYXJyYXkgYW5kIHVzZWRcbiAgICAgICAgYiA9IHA7IC8vIGFueSB0aW1lIEd4IG11bHRpcGxpY2F0aW9uIGlzIGRvbmUuXG4gICAgICAgIHBvaW50cy5wdXNoKGIpOyAvLyBUaGV5IGNvbnN1bWUgMTYtMzIgTWlCIG9mIFJBTS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAyICoqIChXIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgYiA9IGIuYWRkKHApO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYik7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IGIuZG91YmxlKCk7IC8vIFByZWNvbXB1dGVzIGRvbid0IHNwZWVkLXVwIGdldFNoYXJlZEtleSxcbiAgICB9IC8vIHdoaWNoIG11bHRpcGxpZXMgdXNlciBwb2ludCBieSBzY2FsYXIsXG4gICAgcmV0dXJuIHBvaW50czsgLy8gd2hlbiBwcmVjb21wdXRlcyBhcmUgdXNpbmcgYmFzZSBwb2ludFxufTtcbmxldCBHcG93cyA9IHVuZGVmaW5lZDsgLy8gcHJlY29tcHV0ZXMgZm9yIGJhc2UgcG9pbnQgR1xuY29uc3Qgd05BRiA9IChuKSA9PiB7XG4gICAgLy8gQ29tcGFyZWQgdG8gb3RoZXIgcG9pbnQgbXVsdCBtZXRob2RzLFxuICAgIGNvbnN0IGNvbXAgPSBHcG93cyB8fCAoR3Bvd3MgPSBwcmVjb21wdXRlKCkpOyAvLyBzdG9yZXMgMnggbGVzcyBwb2ludHMgdXNpbmcgc3VidHJhY3Rpb25cbiAgICBjb25zdCBuZWcgPSAoY25kLCBwKSA9PiB7IGxldCBuID0gcC5uZWdhdGUoKTsgcmV0dXJuIGNuZCA/IG4gOiBwOyB9OyAvLyBuZWdhdGVcbiAgICBsZXQgcCA9IEksIGYgPSBHOyAvLyBmIG11c3QgYmUgRywgb3IgY291bGQgYmVjb21lIEkgaW4gdGhlIGVuZFxuICAgIGNvbnN0IHdpbmRvd3MgPSAxICsgMjU2IC8gVzsgLy8gVz04IDE3IHdpbmRvd3NcbiAgICBjb25zdCB3c2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOCB3aW5kb3cgc2l6ZVxuICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIFc9OCB3aWxsIGNyZWF0ZSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBtYXhOdW0gPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIGZvciAobGV0IHcgPSAwOyB3IDwgd2luZG93czsgdysrKSB7XG4gICAgICAgIGNvbnN0IG9mZiA9IHcgKiB3c2l6ZTtcbiAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTsgLy8gZXh0cmFjdCBXIGJpdHMuXG4gICAgICAgIG4gPj49IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgIGlmICh3Yml0cyA+IHdzaXplKSB7XG4gICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW07XG4gICAgICAgICAgICBuICs9IDFuO1xuICAgICAgICB9IC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gICAgICAgIGNvbnN0IG9mZjEgPSBvZmYsIG9mZjIgPSBvZmYgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyBvZmZzZXRzLCBldmFsdWF0ZSBib3RoXG4gICAgICAgIGNvbnN0IGNuZDEgPSB3ICUgMiAhPT0gMCwgY25kMiA9IHdiaXRzIDwgMDsgLy8gY29uZGl0aW9ucywgZXZhbHVhdGUgYm90aFxuICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgIGYgPSBmLmFkZChuZWcoY25kMSwgY29tcFtvZmYxXSkpOyAvLyBiaXRzIGFyZSAwOiBhZGQgZ2FyYmFnZSB0byBmYWtlIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vICAgICAgICAgIF4gY2FuJ3QgYWRkIG9mZjIsIG9mZjIgPSBJXG4gICAgICAgICAgICBwID0gcC5hZGQobmVnKGNuZDIsIGNvbXBbb2ZmMl0pKTsgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHAsIGYgfTsgLy8gcmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHMgZm9yIEpJVFxufTsgLy8gISEgeW91IGNhbiBkaXNhYmxlIHByZWNvbXB1dGVzIGJ5IGNvbW1lbnRpbmctb3V0IGNhbGwgb2YgdGhlIHdOQUYoKSBpbnNpZGUgUG9pbnQjbXVsKClcbmV4cG9ydCB7IGdldFB1YmxpY0tleSwgZ2V0UHVibGljS2V5QXN5bmMsIHNpZ24sIHZlcmlmeSwgLy8gUmVtb3ZlIHRoZSBleHBvcnQgdG8gZWFzaWx5IHVzZSBpbiBSRVBMXG5zaWduQXN5bmMsIHZlcmlmeUFzeW5jLCBDVVJWRSwgZXRjLCB1dGlscywgUG9pbnQgYXMgRXh0ZW5kZWRQb2ludCB9OyAvLyBlbnZzIGxpa2UgYnJvd3NlciBjb25zb2xlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/@noble+ed25519@2.2.3/node_modules/@noble/ed25519/index.js\n");

/***/ })

};
;